---
title: "Overview: programs"
description: Overview
sidebar:
  label: Overview
  order: 1
  badge:
    text: Unfinished
    variant: caution
---

Shader programs contain the code used by the GPU to render the graphics. More information on the rendering pipeline can be found at the [Khronos Wiki](https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview). The list of supported stages and their shader filenames are as follows:

| Shader Stage | File Extension |
| ------------ | -------------- |
| Compute      | .csh           |
| Vertex       | .vsh           |
| Geometry     | .gsh           |
| Fragment     | .fsh           |
| Tessellation | .tcs, .tes     |

The shader code of a stage of a program should be located in the file `<program_name>.<stage_extension>`. For example: `composite.vsh`, `deferred8.fsh`, `gbuffers_terrain.gsh`, `setup.csh`


## Program Order
The following is the list of shader programs in the order they're executed:

| Shader Programs                                        | Program Type    |
| ------------------------------------------------------ | --------------- |
| [setup](/reference/programs/setup) (1-99)              | Compute Only    |
| [begin](/reference/programs/begin) (1-99)              | Composite-Style |
| [shadow](/reference/programs/shadow)                   | Gbuffers-Style  |
| [shadowcomp](/reference/programs/shadow_comp) (1-99)   | Composite-Style |
| [prepare](/reference/programs/prepare) (1-99)          | Composite-Style |
| [gbuffers](/reference/programs/gbuffers) (opaque)      | Gbuffers-Style  |
| [deferred](/reference/programs/deferred) (1-99)        | Composite-Style |
| [gbuffers](/reference/programs/gbuffers) (translucent) | Gbuffers-Style  |
| [composite](/reference/programs/composite) (1-99)      | Composite-Style |
| [final](/reference/programs/final)                     | Composite-Style |

> **Note**: Other than some [gbuffers](/reference/programs/gbuffers) programs being before/after [deferred](/reference/programs/deferred), the order of gbuffers programs is not fixed.

#### Gbuffers-Style
Gbuffers-style programs render the actual geometry of Minecraft, such as blocks, entities, etc. These consist of the [gbuffers](/reference/programs/gbuffers) and [shadow](/reference/program/shadow) programs. The [gbuffers](/reference/programs/gbuffers) programs render the scene from the player camera's perspective, and if enabled the [shadow](/reference/program/shadow) program will render the scene from the light source's perspective. These passes require vertex and fragment shaders, and also support geometry and tessellation shaders, but **do not** support compute shaders.
> **Note**: These are the only programs with direct access to geometry specific information through vertex attributes (and certain uniforms).

#### Composite-Style
Composite-style programs render a single quad covering the output texture (unless only compute shaders are present). These programs consist of the [begin](/reference/programs/begin), [shadowcomp](/reference/programs/shadowcomp), [prepare](/reference/programs/prepare), [deferred](/reference/programs/deferred), [composite](/reference/programs/composite), and [final](/reference/programs/final) programs. These programs don't have direct access to any geometry attributes, and instead rely on reading information from textures, buffers, or uniforms. Composite-style programs are commonly used for post-processing effects, deferred rendering, and compute passes. Each composite-style pass can include up to 100 programs by adding a suffix (1 to 99) in addition to a program with no suffix.

All shader stages are supported for composite-style programs (vertex, fragment, geometry, tessellation, and compute). Usually composite-style programs require vertex and fragment shaders, however if a compute shader is present these are optional. Compute shaders will be executed before the vertex stage of a given program.

#### Compute Only
As the name suggests, compute only programs only support compute shaders. The only such programs are the [setup](/reference/programs/setup) programs, which are executed once after shader load and during window resize. Like composite passes, [setup](/reference/programs/setup) supports suffixes (1 to 99) in addition to a program with no suffix.


## Compute Shaders
Compute shaders break the OpenGL fixed pipeline and allow more direct access to graphics hardware. For more information, see the [Khronos Wiki](https://www.khronos.org/opengl/wiki/Compute_Shader).

In Iris, compute shaders can be used in compute only programs, or included in composite-style programs. In composite-style programs, compute shaders will always execute first (before the vertex stage if present). Up to 27 compute shaders files can be included in a single program by appending the `_a` through `_z` suffixes to the filename in addition to a shader file with no suffix. These shaders will execute one after the other in alphabetical order (starting with the no-suffix file if present), unless [`allowConcurrentCompute`](/reference/shadersproperties/allowconcurrentcompute) is used (in which case they will execute potentially simultaneously but will all finish before starting the vertex stage).

Local size is defined as follows: `layout (local_size_x = <size_x>, local_size_y = <size_x>, local_size_y = <size_z>) in;`.

Work group count can be defined one of three ways:
1. **Fixed size**: a const in shader file `const ivec3 workGroups = ivec3(<groups_x>, <groups_y>, <groups_z>);`
2. **Screen size**: calculate work groups as a multiplier of screen resolution, a const in shader file `const vec2 workGroupsRender = vec2(<x_mult>, <y_mult>);`
3. **Indirect**: specify work groups in an SSBO through [`indirect.pass`](/reference/shadersproperties/indirect_pass)

If no work group count is provided, the default value of one work group per pixel will be used (`const vec2 workGroupsRender = vec2(1.0, 1.0);`).

Unlike fragment shaders, compute shaders cannot directly write to color attachments, instead they can only write to [colortex](/reference/buffers/colortex) and [shadowcolor](/reference/programs/shadowcolor) buffers through [`imageStore`](https://www.khronos.org/opengl/wiki/Image_Load_Store). Additionally, if multiple shader invocations are writing/reading to the same location in memory simultaneously, atomic operations (on [images](https://www.khronos.org/opengl/wiki/Image_Load_Store#Atomic_operations) and/or [shared memory](https://www.khronos.org/opengl/wiki/Compute_Shader#Atomic_operations)) or [memory barriers](https://www.khronos.org/opengl/wiki/Compute_Shader#Shared_memory_coherency) should be used.


## Tessellation Shaders

TBD